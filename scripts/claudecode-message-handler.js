#!/usr/bin/env node

/**
 * ClaudeCode Message Handler
 * Automatically processes collaboration messages and triggers appropriate actions
 */

const fs = require('fs').promises;
const path = require('path');

const PROJECT_DIR = '/Users/ted/snap3';
const MESSAGE_PATTERN = /^\.collab-msg-(.+)$/;

class ClaudeCodeMessageHandler {
    constructor() {
        this.lastCheck = new Date();
        this.isProcessing = false;
    }

    async log(message) {
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] ${message}\n`;
        
        try {
            await fs.appendFile(path.join(PROJECT_DIR, 'logs/claudecode-handler.log'), logMessage);
        } catch (error) {
            console.error('Logging failed:', error.message);
        }
        
        console.log(`[ClaudeCode Handler] ${message}`);
    }

    async findNewMessages() {
        try {
            const files = await fs.readdir(PROJECT_DIR);
            const messageFiles = [];
            
            for (const file of files) {
                if (MESSAGE_PATTERN.test(file)) {
                    const filePath = path.join(PROJECT_DIR, file);
                    const stats = await fs.stat(filePath);
                    
                    if (stats.mtime > this.lastCheck) {
                        messageFiles.push({
                            name: file,
                            path: filePath,
                            mtime: stats.mtime
                        });
                    }
                }
            }
            
            return messageFiles.sort((a, b) => a.mtime - b.mtime);
        } catch (error) {
            await this.log(`❌ Error finding messages: ${error.message}`);
            return [];
        }
    }

    async analyzeMessage(messageFile) {
        try {
            const content = await fs.readFile(messageFile.path, 'utf8');
            
            const analysis = {
                urgent: /urgent|critical|즉시|긴급/i.test(content),
                apiTask: /api.*integration|endpoint|implement/i.test(content),
                uiTask: /ui.*integration|frontend|form/i.test(content),
                testTask: /test|validation|verify/i.test(content),
                deployTask: /deploy|production|release/i.test(content),
                cursorTask: /cursor/i.test(content),
                gpt5Task: /gpt-?5|gpt5/i.test(content)
            };
            
            return analysis;
        } catch (error) {
            await this.log(`❌ Error analyzing ${messageFile.name}: ${error.message}`);
            return {};
        }
    }

    async generateAutoResponse(messageFile, analysis) {
        const responseName = messageFile.name.replace('.collab-msg-', '.auto-response-claudecode-');
        const responsePath = path.join(PROJECT_DIR, responseName);
        
        let responseContent = `# 🤖 ClaudeCode Auto-Response

**Original Message**: ${messageFile.name}  
**Processed**: ${new Date().toISOString()}  
**Analysis**: ${JSON.stringify(analysis, null, 2)}

---

## 🚀 Automatic Actions Taken

`;

        if (analysis.urgent) {
            responseContent += `### 🚨 URGENT MESSAGE DETECTED
- **Priority escalated**: HIGH
- **Notification sent**: System alert triggered
- **Queue position**: Front of queue

`;
        }

        if (analysis.apiTask) {
            responseContent += `### 🔧 API Task Identified
- **Action**: API implementation task queued
- **Focus**: Backend integration work
- **Tools**: Ready for API development

`;
        }

        if (analysis.uiTask) {
            responseContent += `### 🎨 UI Task Identified  
- **Action**: Frontend task queued
- **Focus**: UI/UX implementation
- **Tools**: Magic MCP server activated

`;
        }

        if (analysis.cursorTask) {
            responseContent += `### 🤖 Cursor Coordination
- **Action**: Cursor collaboration detected
- **Response**: Ready for Cursor integration
- **Coordination**: Phase-based task delegation

`;
        }

        responseContent += `## ⏰ Processing Queue

1. **Message Analysis**: ✅ Complete
2. **Task Categorization**: ✅ Complete  
3. **Priority Assessment**: ✅ Complete
4. **Action Planning**: 🔄 In Progress
5. **Implementation**: ⏳ Queued

---

**Next Action**: ClaudeCode will process this message in detail upon next session startup.

🤖 *Auto-generated by ClaudeCode Message Handler v1.0*
`;

        await fs.writeFile(responsePath, responseContent);
        await this.log(`✅ Auto-response generated: ${responseName}`);
        
        return responsePath;
    }

    async processNewMessages() {
        if (this.isProcessing) return;
        
        this.isProcessing = true;
        
        try {
            const newMessages = await this.findNewMessages();
            
            if (newMessages.length === 0) {
                return;
            }
            
            await this.log(`📩 Processing ${newMessages.length} new messages`);
            
            for (const messageFile of newMessages) {
                await this.log(`🔍 Analyzing: ${messageFile.name}`);
                
                const analysis = await this.analyzeMessage(messageFile);
                const responsePath = await this.generateAutoResponse(messageFile, analysis);
                
                if (analysis.urgent) {
                    console.log(`🚨 URGENT MESSAGE: ${messageFile.name}`);
                    console.log(`📝 Auto-response: ${path.basename(responsePath)}`);
                }
            }
            
            this.lastCheck = new Date();
            
        } catch (error) {
            await this.log(`❌ Error processing messages: ${error.message}`);
        } finally {
            this.isProcessing = false;
        }
    }

    async startMonitoring() {
        await this.log('🚀 ClaudeCode Message Handler started');
        console.log('🚀 ClaudeCode Auto-Message Handler started');
        console.log(`📁 Monitoring: ${PROJECT_DIR}`);
        console.log('🔄 Checking for new messages every 3 seconds...\n');
        
        // Initial check
        await this.processNewMessages();
        
        // Set up interval monitoring
        setInterval(async () => {
            await this.processNewMessages();
        }, 3000);
    }
}

// Main execution
if (require.main === module) {
    const handler = new ClaudeCodeMessageHandler();
    
    const command = process.argv[2] || 'start';
    
    switch (command) {
        case 'start':
            handler.startMonitoring().catch(console.error);
            break;
        case 'check':
            handler.processNewMessages().then(() => {
                console.log('✅ One-time check completed');
                process.exit(0);
            }).catch(console.error);
            break;
        default:
            console.log('Usage: node claudecode-message-handler.js {start|check}');
            process.exit(1);
    }
}

module.exports = ClaudeCodeMessageHandler;