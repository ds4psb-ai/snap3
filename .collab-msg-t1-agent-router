# ğŸ“¨ T1 - Agent Router í•µì‹¬ ì—”ì§„ êµ¬í˜„

**Priority**: CRITICAL  
**Action**: Agent-Router-Core-Engine  
**Correlation-ID**: T1-AGENT-ROUTER-001  
**Timeline**: T+15~45ë¶„ í•µì‹¬ êµ¬í˜„

---

## ğŸ¯ **T1 Main Terminal - Agent Router êµ¬í˜„ (ì¦‰ì‹œ ì‹¤í–‰)**

### **Phase 2: Agent Router í•µì‹¬ ì—”ì§„**
```bash
cd /Users/ted/snap3

# 1. Agent Router í•µì‹¬ ì—”ì§„ êµ¬í˜„
cat > ai-collab/agent-router.ts <<'TYPESCRIPT'
import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';

interface ContextRules {
  version: number;
  signals: {
    file_patterns: Record<string, string[]>;
    commit_conventions: Record<string, {weight: number}>;
    code_complexity: {high_threshold: number};
  };
  routing: {
    weights_by_context: Record<string, Record<string, number>>;
  };
  thresholds: {
    consensus: {proceed: number; modify: number; reject: number};
  };
}

interface DecisionResult {
  context: string;
  assignees: string[];
  weights: Record<string, number>;
  decision: 'proceed' | 'modify' | 'reject';
  consensus_score: number;
  recommendations: string[];
  correlation_id: string;
}

class UniversalAgentRouter {
  private rules: ContextRules;
  private recentSuccess: Record<string, number> = {};
  
  constructor() {
    const rulesPath = path.join(__dirname, '../configs/context-engine.rules.yaml');
    const rulesContent = fs.readFileSync(rulesPath, 'utf8');
    this.rules = yaml.load(rulesContent) as ContextRules;
  }

  detectContext(fileChanges: string[], commitMessage?: string): string {
    const scores: Record<string, number> = {};
    
    // íŒŒì¼ íŒ¨í„´ ê¸°ë°˜ ì ìˆ˜ ê³„ì‚°
    for (const [context, patterns] of Object.entries(this.rules.signals.file_patterns)) {
      scores[context] = 0;
      
      for (const file of fileChanges) {
        for (const pattern of patterns) {
          const regex = new RegExp(pattern.replace('**/', '.*').replace('*', '[^/]*'));
          if (regex.test(file)) {
            scores[context] += 1;
          }
        }
      }
    }
    
    // ì»¤ë°‹ ë©”ì‹œì§€ ê¸°ë°˜ ê°€ì¤‘ì¹˜ ì ìš©
    if (commitMessage) {
      for (const [convention, config] of Object.entries(this.rules.signals.commit_conventions)) {
        if (commitMessage.startsWith(convention + ':')) {
          const topContext = Object.entries(scores).sort((a, b) => b[1] - a[1])[0];
          if (topContext) {
            scores[topContext[0]] *= config.weight;
          }
        }
      }
    }
    
    // ìµœê³  ì ìˆ˜ ì»¨í…ìŠ¤íŠ¸ ë°˜í™˜
    const topContext = Object.entries(scores).sort((a, b) => b[1] - a[1])[0];
    return topContext ? topContext[0] : 'architecture';
  }

  async routeDecision(context: string, correlationId: string): Promise<DecisionResult> {
    const contextWeights = this.rules.routing.weights_by_context[context] || {};
    
    // SLO ìƒíƒœ í™•ì¸
    const sloData = await this.checkSLOStatus();
    
    // ë™ì  ê°€ì¤‘ì¹˜ ê³„ì‚° (ì„±ê³¼ ê¸°ë°˜)
    const finalWeights = this.calculateDynamicWeights(contextWeights, context);
    
    // í•©ì˜ ì ìˆ˜ ê³„ì‚°
    const consensusScore = this.calculateConsensusScore(finalWeights, sloData);
    
    // ì˜ì‚¬ê²°ì •
    let decision: 'proceed' | 'modify' | 'reject' = 'proceed';
    if (consensusScore < this.rules.thresholds.consensus.reject) {
      decision = 'reject';
    } else if (consensusScore < this.rules.thresholds.consensus.proceed) {
      decision = 'modify';
    }

    return {
      context,
      assignees: Object.keys(finalWeights),
      weights: finalWeights,
      decision,
      consensus_score: consensusScore,
      recommendations: this.generateRecommendations(context, consensusScore, sloData),
      correlation_id: correlationId
    };
  }

  private async checkSLOStatus(): Promise<any> {
    try {
      const response = await fetch('http://localhost:8080/api/circuit-breaker/status');
      return await response.json();
    } catch {
      return { state: { state: 'UNKNOWN' }, performance_metrics: {} };
    }
  }

  private calculateDynamicWeights(baseWeights: Record<string, number>, context: string): Record<string, number> {
    const weights = { ...baseWeights };
    
    // ìµœê·¼ ì„±ê³¼ ê¸°ë°˜ ì¡°ì •
    for (const agent of Object.keys(weights)) {
      const successRate = this.recentSuccess[`${agent}_${context}`] || 1.0;
      weights[agent] *= successRate;
    }
    
    // ì •ê·œí™”
    const total = Object.values(weights).reduce((sum, w) => sum + w, 0);
    for (const agent of Object.keys(weights)) {
      weights[agent] /= total;
    }
    
    return weights;
  }

  private calculateConsensusScore(weights: Record<string, number>, sloData: any): number {
    let score = 0.7; // ê¸°ë³¸ ì ìˆ˜
    
    // SLO ìƒíƒœ ë°˜ì˜
    if (sloData.state?.state === 'CLOSED') score += 0.1;
    if (sloData.performance_metrics?.success_rate === '100.00%') score += 0.1;
    
    // ê°€ì¤‘ì¹˜ ë¶„ì‚°ë„ ë°˜ì˜ (ì§‘ì¤‘ë„ê°€ ë†’ì„ìˆ˜ë¡ ì ìˆ˜ ìƒìŠ¹)
    const entropy = -Object.values(weights).reduce((sum, w) => sum + w * Math.log(w), 0);
    score += (1 - entropy / Math.log(Object.keys(weights).length)) * 0.1;
    
    return Math.min(score, 1.0);
  }

  private generateRecommendations(context: string, score: number, sloData: any): string[] {
    const recommendations: string[] = [];
    
    if (score < 0.8) {
      recommendations.push('í•©ì˜ ì ìˆ˜ê°€ ë‚®ìŠµë‹ˆë‹¤. ì—ì´ì „íŠ¸ í˜‘ì—… ê²€í†  í•„ìš”');
    }
    
    if (sloData.state?.state !== 'CLOSED') {
      recommendations.push('Circuit Breakerê°€ ì—´ë¦° ìƒíƒœì…ë‹ˆë‹¤. ì‹œìŠ¤í…œ ì•ˆì •ì„± í™•ì¸ í•„ìš”');
    }
    
    if (context === 'frontend') {
      recommendations.push('Frontend ì»¨í…ìŠ¤íŠ¸: Cursor ì£¼ë„ ê°œë°œ ê¶Œì¥');
    } else if (context === 'backend') {
      recommendations.push('Backend ì»¨í…ìŠ¤íŠ¸: ClaudeCode ì£¼ë„ ê°œë°œ ê¶Œì¥');
    }
    
    return recommendations;
  }
}

export const agentRouter = new UniversalAgentRouter();
TYPESCRIPT

# 2. í•„ìš”í•œ ì˜ì¡´ì„± ì„¤ì¹˜
npm install js-yaml @types/js-yaml

# 3. Agent Router API ì—”ë“œí¬ì¸íŠ¸ ìƒì„±
cat > src/app/api/agent-router/route.ts <<'TYPESCRIPT'
import { NextRequest, NextResponse } from 'next/server';
import { agentRouter } from '../../../ai-collab/agent-router';

export async function POST(request: NextRequest) {
  try {
    const { fileChanges, commitMessage, correlationId } = await request.json();
    
    const context = agentRouter.detectContext(fileChanges || [], commitMessage);
    const decision = await agentRouter.routeDecision(context, correlationId || `AR-${Date.now()}`);
    
    return NextResponse.json(decision);
  } catch (error) {
    return NextResponse.json({
      error: 'Agent routing failed',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}
TYPESCRIPT

echo "âœ… [T1] Agent Router í•µì‹¬ ì—”ì§„ êµ¬í˜„ ì™„ë£Œ"
```

### **Phase 2 ì™„ë£Œ ì‹ í˜¸**
```bash
# Agent Router êµ¬í˜„ ì™„ë£Œ í‘œì‹œ
touch .t1-agent-router-ready
echo "T1-AGENT-ROUTER-COMPLETE-$(date +%s)" > .t1-agent-router-ready

# êµ¬í˜„ í™•ì¸
echo "ğŸ“ [T1] ìƒì„±ëœ íŒŒì¼:"
ls -la ai-collab/agent-router.ts
ls -la src/app/api/agent-router/route.ts
ls -la src/app/api/universal/status/route.ts
```

---

**T1 ì‹¤í–‰ ëª…ë ¹ì–´**: `cd /Users/ted/snap3 && cat .collab-msg-t1-agent-router`