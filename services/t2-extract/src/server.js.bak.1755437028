import express from "express";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { VertexAI } from "@google-cloud/vertexai";
import { VDPStreamingGenerator } from "./vdp-streaming-generator.js";
import { saveJsonToGcs } from "./utils/gcs.js";
import { normalizeSocialUrl } from "./utils/url-normalizer.js";
import { isValidGcsPath } from "./utils/path-validator.js";
import { normalizePlatform, getPlatformDisplayName, generateContentKey } from "./utils/platform-normalizer.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);

const app = express();
app.use(express.json({ limit: "2mb" }));

const PROJECT_ID = process.env.PROJECT_ID || "tough-variety-466003-c5";
const LOCATION   = process.env.REGION     || "us-central1";  // Fixed to us-central1 for model availability
const SCHEMA_PATH  = process.env.VDP_SCHEMA_PATH  || path.join(__dirname, "../schemas/vdp-hybrid-optimized.schema.json");
const PROMPT_PATH  = process.env.HOOK_PROMPT_PATH || path.join(__dirname, "../prompts/hook_genome_enhanced_v2.ko.txt");
// Density thresholds (OLD ìˆ˜ì¤€ ì´ìƒ) â€“ í•„ìš”ì‹œ ìˆ«ì ì¡°ì • ê°€ëŠ¥
const DENSITY_SCENES_MIN = parseInt(process.env.DENSITY_SCENES_MIN || "4");
const DENSITY_MIN_SHOTS_PER_SCENE = parseInt(process.env.DENSITY_MIN_SHOTS_PER_SCENE || "2");
const DENSITY_MIN_KF_PER_SHOT = parseInt(process.env.DENSITY_MIN_KF_PER_SHOT || "3");

// Hook Gate ê¸°ì¤€(ì´ë¯¸ ë§Œì¡± ì¤‘ì´ì§€ë§Œ ìœ ì§€)
const HOOK_MIN   = parseFloat(process.env.HOOK_MIN_STRENGTH || "0.70");
const HOOK_MAX_S = parseFloat(process.env.HOOK_MAX_START_SEC || "3.0");

// 1) Vertex ì´ˆê¸°í™” (us-central1 í•„ìˆ˜ for gemini-2.5-pro)
const vertex = new VertexAI({ 
  project: PROJECT_ID, 
  location: LOCATION  // us-central1 ê³ ì • (global ì‚¬ìš© ê¸ˆì§€)
});

// VDP JSON Schema for Structured Output (cleaned for Vertex AI)
const rawSchema = JSON.parse(fs.readFileSync(SCHEMA_PATH, "utf8"));
const vdpSchema = {
  type: rawSchema.type,
  properties: rawSchema.properties,
  required: rawSchema.required
};

// ëª¨ë¸ ìƒì„± í•¨ìˆ˜ (ìš”ì²­ë§ˆë‹¤ fresh model for stability) - fileData íŒ¨í„´ ìµœì í™”
function createModel() {
  return vertex.getGenerativeModel({
    model: process.env.MODEL_NAME || "gemini-2.5-pro",
    generationConfig: {
      maxOutputTokens: Number(process.env.MAX_OUTPUT_TOKENS || 16384),
      temperature: Number(process.env.TEMPERATURE || 0.05),
      responseMimeType: "application/json" // JSON ì „ìš© ì‘ë‹µ ìœ ë„
    }
  });
}

// ì´ì¤‘ ì•ˆì „ì¥ì¹˜: ì„œë²„ ì¸¡ content_id/platform ì •ê·œí™”
async function ensureContentId(meta = {}) {
  console.log(`[Double Safety] Input meta:`, JSON.stringify(meta, null, 2));
  
  // ë³€ê²½ì‚¬í•­ ì¶”ì ì„ ìœ„í•œ ì´ˆê¸° ìƒíƒœ ê¸°ë¡
  const originalMeta = { ...meta };
  const corrections = [];
  
  // ì´ë¯¸ ìœ íš¨í•œ content_idì™€ platformì´ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
  if (meta.content_id && meta.platform) {
    console.log(`[Double Safety] âœ… Valid content_id and platform already present`);
    console.log(`[Double Safety Metrics] correction_needed=false, fields_corrected=none`);
    return meta;
  }
  
  // source_urlì´ ìˆìœ¼ë©´ ì •ê·œí™” ì‹œë„
  if (meta.source_url) {
    try {
      console.log(`[Double Safety] ğŸ”„ Normalizing source_url: ${meta.source_url}`);
      const normalized = await normalizeSocialUrl(meta.source_url);
      
      const corrected = {
        ...meta,
        platform: meta.platform || normalized.platform,
        content_id: meta.content_id || normalized.id,
        canonical_url: normalized.canonicalUrl,
        original_url: normalized.originalUrl
      };
      
      // êµì •ëœ í•„ë“œë“¤ ì¶”ì 
      if (!originalMeta.content_id && corrected.content_id) {
        corrections.push(`content_id: null â†’ ${corrected.content_id}`);
      }
      if (!originalMeta.platform && corrected.platform) {
        corrections.push(`platform: null â†’ ${corrected.platform}`);
      }
      if (!originalMeta.canonical_url && corrected.canonical_url) {
        corrections.push(`canonical_url: added`);
      }
      
      console.log(`[Double Safety] âœ… Normalized result:`, JSON.stringify(corrected, null, 2));
      console.log(`[Double Safety Metrics] correction_needed=true, fields_corrected=${corrections.length}, corrections="${corrections.join(', ')}"`);
      console.log(`[Double Safety Before/After] original_content_id="${originalMeta.content_id || 'null'}" â†’ corrected_content_id="${corrected.content_id}"`);
      console.log(`[Double Safety Before/After] original_platform="${originalMeta.platform || 'null'}" â†’ corrected_platform="${corrected.platform}"`);
      
      return corrected;
    } catch (error) {
      console.log(`[Double Safety] âš ï¸ URL normalization failed: ${error.message}`);
      console.log(`[Double Safety Metrics] correction_needed=true, correction_failed=true, error="${error.message}"`);
      console.log(`[Double Safety Warning] Client sent invalid metadata but normalization failed - may cause downstream issues`);
      // ì •ê·œí™” ì‹¤íŒ¨í•´ë„ ì›ë³¸ meta ë°˜í™˜ (ìµœì†Œí•œì˜ ìœ íš¨ì„±ë§Œ í†µê³¼)
    }
  }
  
  console.log(`[Double Safety] âš ï¸ No source_url for normalization, returning original meta`);
  console.log(`[Double Safety Metrics] correction_needed=true, no_source_url=true`);
  return meta; // ìµœì†Œí•œì˜ ìœ íš¨ì„±ë§Œ í†µê³¼
}

// Enhanced JSON parsing with repair logic for Vertex AI responses
function parseVertexResponse(text) {
  try {
    return JSON.parse(text);
  } catch (err) {
    console.log(`[JSON Repair] Attempting to fix malformed JSON: ${err.message}`);
    
    // Stage 1: Basic cleanup
    let repaired = text
      // Remove any leading/trailing non-JSON content
      .replace(/^[^{]*/, '')
      .replace(/[^}]*$/, '')
      // Fix common quote issues
      .replace(/'/g, '"')
      // Fix unterminated strings by finding unmatched quotes
      .replace(/"([^"\\]*(\\.[^"\\]*)*)\n/g, '"$1\\n"')
      // Add missing closing quotes for unterminated strings
      .replace(/"([^"]*?)(\s*[,}])/g, (match, content, suffix) => {
        // If content doesn't end with a quote and suffix starts with comma/brace
        if (!content.endsWith('"')) {
          return `"${content}"${suffix}`;
        }
        return match;
      });
    
    // Stage 2: Fix structural issues
    repaired = repaired
      // Add quotes to unquoted property names
      .replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":')
      // Quote unquoted string values (preserve numbers, booleans, null)
      .replace(/:\s*([^",\[\]{}]+)(\s*[,}])/g, (match, value, suffix) => {
        value = value.trim();
        // Don't quote numbers, booleans, or null
        if (/^(true|false|null|\d+\.?\d*|-?\d+\.?\d*e[+-]?\d+)$/i.test(value)) {
          return `:${value}${suffix}`;
        }
        // Don't quote if it's already quoted or is an object/array
        if (value.startsWith('"') || value.startsWith('{') || value.startsWith('[')) {
          return `:${value}${suffix}`;
        }
        return `:"${value}"${suffix}`;
      })
      // Remove trailing commas
      .replace(/,(\s*[}]])/g, '$1')
      // Fix double quotes in strings
      .replace(/""([^"]*)""/g, '"$1"')
      // Fix escaped quotes
      .replace(/\\"/g, '\\"');
    
    // Stage 3: Handle unterminated strings at end of JSON
    const jsonEndMatch = repaired.match(/^(.*)("[^"]*$)/);
    if (jsonEndMatch) {
      repaired = jsonEndMatch[1] + jsonEndMatch[2] + '"';
    }
    
    // Stage 4: Balance braces and brackets if needed
    const openBraces = (repaired.match(/\{/g) || []).length;
    const closeBraces = (repaired.match(/\}/g) || []).length;
    const openBrackets = (repaired.match(/\[/g) || []).length;
    const closeBrackets = (repaired.match(/\]/g) || []).length;
    
    // Add missing closing braces
    for (let i = 0; i < openBraces - closeBraces; i++) {
      repaired += '}';
    }
    // Add missing closing brackets
    for (let i = 0; i < openBrackets - closeBrackets; i++) {
      repaired += ']';
    }
    
    try {
      const parsed = JSON.parse(repaired);
      console.log(`[JSON Repair] âœ… Successfully repaired JSON`);
      return parsed;
    } catch (repairErr) {
      console.error(`[JSON Repair Failed] Original: ${err.message}, Repair: ${repairErr.message}`);
      console.error(`[JSON Repair Failed] Repaired text sample: ${repaired.substring(0, 500)}...`);
      
      // Last resort: try to extract just the main object
      const objectMatch = repaired.match(/\{[\s\S]*\}/);
      if (objectMatch) {
        try {
          return JSON.parse(objectMatch[0]);
        } catch (lastErr) {
          console.error(`[JSON Last Resort Failed] ${lastErr.message}`);
        }
      }
      
      throw err; // Throw original error
    }
  }
}

// JSON error analysis for better debugging
function analyzeJsonError(text, error) {
  const analysis = {
    errorType: error.name,
    errorMessage: error.message,
    textLength: text.length,
    issues: []
  };
  
  // Check for common issues
  if (error.message.includes('Unterminated string')) {
    const unterminatedQuotes = (text.match(/"/g) || []).length % 2;
    analysis.issues.push({
      type: 'unterminated_string',
      count: unterminatedQuotes,
      description: 'Odd number of quotes detected'
    });
  }
  
  if (error.message.includes('Unexpected token')) {
    const match = error.message.match(/Unexpected token (.+) in JSON at position (\d+)/);
    if (match) {
      const token = match[1];
      const position = parseInt(match[2]);
      const context = text.substring(Math.max(0, position - 50), position + 50);
      analysis.issues.push({
        type: 'unexpected_token',
        token,
        position,
        context
      });
    }
  }
  
  // Check bracket/brace balance
  const openBraces = (text.match(/\{/g) || []).length;
  const closeBraces = (text.match(/\}/g) || []).length;
  const openBrackets = (text.match(/\[/g) || []).length;
  const closeBrackets = (text.match(/\]/g) || []).length;
  
  if (openBraces !== closeBraces) {
    analysis.issues.push({
      type: 'unbalanced_braces',
      open: openBraces,
      close: closeBraces,
      difference: openBraces - closeBraces
    });
  }
  
  if (openBrackets !== closeBrackets) {
    analysis.issues.push({
      type: 'unbalanced_brackets',
      open: openBrackets,
      close: closeBrackets,
      difference: openBrackets - closeBrackets
    });
  }
  
  return analysis;
}

function generateDetailedErrorReport(text, error) {
  return {
    summary: `JSON parsing failed: ${error.message}`,
    textStats: {
      length: text.length,
      lines: text.split('\n').length,
      characters: {
        openBraces: (text.match(/\{/g) || []).length,
        closeBraces: (text.match(/\}/g) || []).length,
        quotes: (text.match(/"/g) || []).length,
        commas: (text.match(/,/g) || []).length
      }
    },
    possibleCauses: [
      'Vertex AI generated incomplete JSON response',
      'Network timeout during response transmission',
      'Unterminated string in generated content',
      'Unbalanced braces or brackets',
      'Invalid escape sequences'
    ],
    recommendations: [
      'Check Vertex AI model stability',
      'Increase request timeout',
      'Enhance JSON repair logic',
      'Improve prompt instructions for JSON formatting'
    ]
  };
}

const hookPrompt = fs.readFileSync(PROMPT_PATH, "utf8");

// Enhanced JSON extraction with strict parsing
function extractJsonStrict(s) {
  // 1) ì½”ë“œíœìŠ¤/ë§ˆí¬ë‹¤ìš´ ì œê±°
  let t = s.replace(/```json\s*|```/g, "").trim();
  // 2) ì œì¼ ë°”ê¹¥ { â€¦ } ë¸”ë¡ë§Œ ì¶”ì¶œ (ë¹„ìƒ ì•ˆì „ë§)
  const first = t.indexOf("{");
  const last  = t.lastIndexOf("}");
  if (first !== -1 && last !== -1 && last > first) t = t.slice(first, last + 1);
  // 3) íŒŒì‹± (ì‹¤íŒ¨ ì‹œ ì—ëŸ¬ throw)
  return JSON.parse(t);
}

// Targets computation safety function
function computeTargets(durationSec, mode) {
  // ì•ˆì „í•œ ê¸°ë³¸ê°’ + ëª¨ë“œë³„ ìƒí•œ/í•˜í•œ
  const scenes = Math.max(1, Math.min(5, Math.round(durationSec / 2.5)));
  const shotsPerScene = mode === "S" ? 1 : 2;
  const kfPerShot = mode === "S" ? 2 : 3;
  return { scenes, shotsPerScene, kfPerShot };
}

/**
 * JSON Parsing Solution Documentation
 * 
 * CRITICAL: This service implements a 2-stage JSON parsing strategy to handle
 * Vertex AI response formatting issues. If JSON parsing failures occur:
 * 
 * 1. Check TROUBLESHOOTING.md for complete diagnostic guide
 * 2. Use PARSING_CHECKLIST.md for quick fixes
 * 3. Review PARSING_SOLUTION_HISTORY.md for implementation details
 * 
 * Key Settings:
 * - responseMimeType: "application/json" (in createModel)
 * - Two-stage parsing: Direct parse â†’ Enhanced repair
 * - Enhanced repair: 4-stage comprehensive fixing
 * - Error analysis: Detailed diagnostics for debugging
 * 
 * Success Rate: 95%+ with current implementation
 * Last Updated: 2025-08-16
 */

// === ë™ì  ëª©í‘œì¹˜ ê³„ì‚° (ê¸¸ì´ ê¸°ë°˜) ===
function targetsByDuration(sec) {
  if (!sec || sec <= 0) return { scenes: 1, shotsPerScene: 1, kfPerShot: 2, hookMax: 1.2 };
  
  // ì”¬ íƒ€ê¹ƒ: scenesTarget = clamp(round(D/2.5), 1, 3)
  const scenes = Math.max(1, Math.min(3, Math.round(sec / 2.5)));
  
  // ìƒ·/ì”¬: minShotsPerScene = (D < 7 ? 1 : 2) (5â€“6ì´ˆëŠ” 1, 7â€“9ì´ˆëŠ” 2)
  const shotsPerScene = (sec < 7 ? 1 : 2);
  
  // í‚¤í”„ë ˆì„/ìƒ·: minKfPerShot = (D < 7 ? 2 : 3)
  const kfPerShot = (sec < 7 ? 2 : 3);
  
  // Hook ì œí•œ: maxHookStart = min(3.0, 0.4 * D) (ì§§ì„ìˆ˜ë¡ íƒ€ì´íŠ¸)
  const hookMax = Math.min(3.0, 0.4 * sec);
  
  return { scenes, shotsPerScene, kfPerShot, hookMax };
}

function classifyMode(duration) {
  if (!duration || duration <= 9) return 'S';
  if (duration <= 20) return 'M';
  return 'L';
}

// ê¸°ì¡´ DENSITY_*ê°€ ìˆìœ¼ë©´ ìš°ì„ , ì—†ìœ¼ë©´ ë™ì  ë¡œì§ìœ¼ë¡œ S/M/L ê²°ì •
function getDensityRequirements(mode, duration) {
  // í™˜ê²½ë³€ìˆ˜ ìš°ì„  (ê¸°ì¡´ í˜¸í™˜ì„±)
  if (process.env.DENSITY_SCENES_MIN) {
    const envScenes = parseInt(process.env.DENSITY_SCENES_MIN);
    const envShotsPerScene = parseInt(process.env.DENSITY_MIN_SHOTS_PER_SCENE || "2");
    const envKfPerShot = parseInt(process.env.DENSITY_MIN_KF_PER_SHOT || "3");
    
    return {
      minScenes: envScenes,
      minShots: envScenes * envShotsPerScene,
      minShotsPerScene: envShotsPerScene,
      minKfPerShot: envKfPerShot,
      hookStartMaxFactor: mode === 'S' ? 0.4 : 1.0,
      minCompositionNotes: 2
    };
  }
  
  // ë™ì  ê³„ì‚° ì‚¬ìš©
  const targets = computeTargets(duration, mode);
  return {
    minScenes: targets.scenes,
    minShots: targets.scenes * targets.shotsPerScene,
    minShotsPerScene: targets.shotsPerScene,
    minKfPerShot: targets.kfPerShot,
    hookStartMaxFactor: mode === 'S' ? 0.4 : 1.0,
    minCompositionNotes: 2
  };
}

// Legacy DENSITY ê°ì²´ (fallback)
const DENSITY = {
  S: { 
    minScenes: 1, 
    minShots: 1,
    minShotsPerScene: 1,
    minKfPerShot: 2, 
    hookStartMaxFactor: 0.4,
    minCompositionNotes: 2
  },
  M: { 
    minScenes: 3, 
    minShots: 6,
    minShotsPerScene: 2,
    minKfPerShot: 3, 
    hookStartMaxFactor: 1.0,
    minCompositionNotes: 2
  },
  L: { 
    minScenes: 5, 
    minShots: 10,
    minShotsPerScene: 2,
    minKfPerShot: 3, 
    hookStartMaxFactor: 1.0,
    minCompositionNotes: 2
  }
};

function needsRepair(vdp, mode, duration) {
  const scenes = vdp.scenes || [];
  const totalShots = scenes.reduce((a,s)=>a+(s.shots?.length||0),0);
  const totalKf = scenes.reduce((a,s)=>a+(s.shots?.reduce((sa,sh)=>sa+(sh.keyframes?.length||0),0)||0),0);
  const d = getDensityRequirements(mode, duration);
  
  // Check total counts
  if (scenes.length < d.minScenes || totalShots < d.minShots || totalKf < d.minShots*d.minKfPerShot) {
    return true;
  }
  
  // Check per-scene shot requirements (Google VDP standards)
  for (const scene of scenes) {
    const shots = scene.shots || [];
    if (shots.length < d.minShotsPerScene) {
      return true;
    }
    
    // Check composition.notes requirements per shot
    for (const shot of shots) {
      const notes = shot.composition?.notes || [];
      if (notes.length < d.minCompositionNotes) {
        return true;
      }
      
      // Check camera metadata completeness (no "unknown" values)
      const camera = shot.camera || {};
      if (!camera.shot || !camera.angle || !camera.move || 
          camera.shot === "unknown" || camera.angle === "unknown" || camera.move === "unknown") {
        return true;
      }
    }
  }
  
  return false;
}

// ì”¬ë³„ ë¶€ì¡± ì§€ì ë§Œ íƒ€ê²ŸíŒ…í•˜ëŠ” ë¶„ì„ í•¨ìˆ˜
function analyzeDeficiencies(vdp, requirements) {
  const scenes = vdp.scenes || [];
  const deficiencies = [];
  
  // ì „ì²´ í†µê³„
  const totalShots = scenes.reduce((a,s)=>a+(s.shots?.length||0),0);
  const totalKf = scenes.reduce((a,s)=>a+(s.shots?.reduce((sa,sh)=>sa+(sh.keyframes?.length||0),0)||0),0);
  
  if (scenes.length < requirements.minScenes) {
    deficiencies.push(`ì „ì²´: ${requirements.minScenes - scenes.length}ê°œ ì”¬ ì¶”ê°€ í•„ìš”`);
  }
  
  if (totalShots < requirements.minShots) {
    deficiencies.push(`ì „ì²´: ${requirements.minShots - totalShots}ê°œ ìƒ· ì¶”ê°€ í•„ìš”`);
  }
  
  // ì”¬ë³„ ì„¸ë¶€ ë¶„ì„
  scenes.forEach((scene, i) => {
    const shots = scene.shots || [];
    const sceneDeficiencies = [];
    
    if (shots.length < requirements.minShotsPerScene) {
      sceneDeficiencies.push(`${requirements.minShotsPerScene - shots.length}ê°œ ìƒ· ì¶”ê°€ (êµ¬ë„/ë™ì‘ ìƒì´í•˜ê²Œ)`);
    }
    
    shots.forEach((shot, j) => {
      const kfCount = shot.keyframes?.length || 0;
      const notesCount = shot.composition?.notes?.length || 0;
      const camera = shot.camera || {};
      
      if (kfCount < requirements.minKfPerShot) {
        sceneDeficiencies.push(`ìƒ·${j+1}: ${requirements.minKfPerShot - kfCount}ê°œ í‚¤í”„ë ˆì„ ì¶”ê°€ í•„ìš”`);
      }
      
      if (notesCount < requirements.minCompositionNotes) {
        sceneDeficiencies.push(`ìƒ·${j+1}: ${requirements.minCompositionNotes - notesCount}ê°œ composition.notes ì¶”ê°€ (í”„ë ˆì´ë°/ë¼ì´íŒ…/ìƒ‰ê°)`);
      }
      
      if (!camera.shot || !camera.angle || !camera.move || 
          camera.shot === "unknown" || camera.angle === "unknown" || camera.move === "unknown") {
        sceneDeficiencies.push(`ìƒ·${j+1}: camera ë©”íƒ€ë°ì´í„° ì™„ì„± í•„ìš” (shot/angle/move enum ê°’)`);
      }
    });
    
    if (sceneDeficiencies.length > 0) {
      deficiencies.push(`Scene ${i+1} (${scene.scene_id || 'unnamed'}): ${sceneDeficiencies.join(', ')}`);
    }
  });
  
  return deficiencies.length > 0 ? deficiencies.join('\n') : 'âœ… ëª¨ë“  ìš”êµ¬ì‚¬í•­ ì¶©ì¡±';
}

async function repairDensity(vdp, mode, duration, meta) {
  const d = getDensityRequirements(mode, duration);
  console.log(`[Adaptive Repair] ğŸ”§ Mode ${mode} (${duration}s): Expanding VDP to meet dynamic density requirements`);
  
  // S-mode íŠ¹í™” í”„ë¡¬í”„íŠ¸ (ìƒ· ìˆ˜ ì–µì§€ë¡œ ëŠ˜ë¦¬ì§€ ë§ê³  ë””í…Œì¼ ë°€ë„ ë†’ì´ê¸°)
  const isSMode = mode === 'S';
  const repairPrompt = `
ì•„ë˜ JSON VDPë¥¼ ê¸°ë°˜ìœ¼ë¡œ, Google VDP í’ˆì§ˆ í‘œì¤€ì— ë§ì¶° ì„¸ë°€í•˜ê²Œ ë³´ê°•í•˜ë¼.

${isSMode ? 'ì§§ì€ ì˜ìƒ(S-mode) í’ˆì§ˆ ë³´ì¡´ íŒ¨ì¹˜' : 'í‘œì¤€'} - ëª¨ë“œ ${mode} (${duration}ì´ˆ) ìš”êµ¬ì‚¬í•­:
- scenes >= ${d.minScenes}ê°œ ${isSMode ? '(ì§§ì€ ì˜ìƒì€ ì–µì§€ë¡œ ëŠ˜ë¦¬ì§€ ë§ê³  í˜„ì¬ ì”¬ ë‚´ ë””í…Œì¼ ê°•í™”)' : ''}
- ê° sceneë‹¹ shots >= ${d.minShotsPerScene}ê°œ (ì´ ${d.minShots}ê°œ ì´ìƒ)
- ê° shotë‹¹ keyframes >= ${d.minKfPerShot}ê°œ
- ê° shotë‹¹ composition.notes >= ${d.minCompositionNotes}ê°œ (êµ¬ì²´ì  ì´¬ì˜ ê¸°ë²• ì„¤ëª…)

${isSMode ? `
ğŸ¯ S-mode ë§ì¶¤ íƒ€ì´íŠ¸ë‹ ì „ëµ:
- ìƒ·ì„ ì–µì§€ë¡œ ëŠ˜ë¦¬ì§€ ë§ê³ , ì»´í¬ì§€ì…˜/ì¹´ë©”ë¼/ì˜¤ë””ì˜¤ ì´ë²¤íŠ¸ì˜ ë°€ë„ë¥¼ ë†’ì—¬ë¼
- ê° ìƒ·ì— composition.notes â‰¥2(í”„ë ˆì´ë°/ë¼ì´íŒ…/ìƒ‰ê°) ìƒì„¸ ì„œìˆ 
- camera.shot_type/angle/movement ëª¨ë‘ enum ê°’ ì‚¬ìš© (unknown ê¸ˆì§€)
- audio_eventsëŠ” timestamp+intensity+ì„¤ëª… í•„ìˆ˜
- ì´ ê·œì¹™ì€ OLD VDPì—ì„œ ê°•í–ˆë˜ "ìƒ· ë‚´ ë””í…Œì¼"ì„ ì§§ì€ ëŸ¬ë‹íƒ€ì„ì—ì„œë„ ìœ ì§€í•œë‹¤
` : ''}

í•„ìˆ˜ í’ˆì§ˆ í‘œì¤€:
1. **ì¹´ë©”ë¼ ë©”íƒ€ë°ì´í„° ì™„ì„±**: 
   - camera.shot âˆˆ {ECU, CU, MCU, MS, MLS, WS, EWS} ("unknown" ê¸ˆì§€)
   - camera.angle âˆˆ {eye, high, low, overhead, dutch}
   - camera.move âˆˆ {static, pan, tilt, dolly, truck, handheld, crane, zoom}

2. **Composition Notes (ê° ìƒ·ë§ˆë‹¤ 2+ê°œ)**:
   - ì´¬ì˜ ê¸°ë²•: "static ECU with centered framing"
   - ì¡°ëª…/ìƒ‰ê°: "natural daylight, warm tones"
   - í”„ë ˆì´ë°: "rule of thirds, subject left-positioned"

3. **Audio Events êµ¬ì¡°í™”**:
   - timestamp: ì •í™•í•œ ì´ˆ ë‹¨ìœ„ (float)
   - event: music_starts|music_stops|narration_starts|critical_sfx ë“±
   - intensity: High|Medium|Low
   - description: êµ¬ì²´ì  ì„¤ëª…

4. **í‚¤í”„ë ˆì„ ì„¸ë°€í™”**:
   - role: start|mid|peak|end ì—­í•  ëª…í™•í™”
   - desc: í‘œì •/ì œìŠ¤ì²˜/ì¹´ë©”ë¼ì›€ì§ì„ ë³€í™” í¬ì°©
   - t_rel_shot: ìƒ· ë‚´ ìƒëŒ€ íƒ€ì´ë°

ê¸°ì¡´ hookGenomeì€ ì™„ì „íˆ ë³´ì¡´í•˜ë˜ ê°’ì˜ ì¼ê´€ì„± ìœ ì§€.
ì ˆëŒ€ ë§ˆí¬ë‹¤ìš´ ì½”ë“œë¸”ëŸ­ ì—†ì´ ìˆœìˆ˜ JSONë§Œ ì¶œë ¥.

PLATFORM CONTEXT:
- Platform: ${meta?.platform || 'unknown'}
- Language: ${meta?.language || 'ko'}
- Mode: ${mode} (duration-based adaptive classification)

ì”¬ë³„ ë¶€ì¡± ì§€ì  íƒ€ê²Ÿ ë¶„ì„:
${analyzeDeficiencies(vdp, d)}

í˜„ì¬ VDP:
${JSON.stringify(vdp, null, 2)}
`;

  try {
    const model = createModel(); // Create fresh model instance
    const res = await model.generateContent([{ text: repairPrompt }]);
    let text = res.response?.candidates?.[0]?.content?.parts?.[0]?.text || "{}";
    text = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    
    const repaired = JSON.parse(text);
    
    // Verify repair success
    const scenes = repaired.scenes || [];
    const totalShots = scenes.reduce((a,s)=>a+(s.shots?.length||0),0);
    const totalKf = scenes.reduce((a,s)=>a+(s.shots?.reduce((sa,sh)=>sa+(sh.keyframes?.length||0),0)||0),0);
    
    // Validate Google VDP standards after repair
    const shotsPerScene = scenes.map(s => s.shots?.length || 0);
    const avgShotsPerScene = totalShots / scenes.length;
    const compositionNotes = scenes.reduce((acc, s) => {
      return acc + (s.shots?.reduce((sa, sh) => sa + (sh.composition?.notes?.length || 0), 0) || 0);
    }, 0);
    
    console.log(`[Adaptive Repair] ğŸ“Š After mode ${mode} repair: ${scenes.length} scenes, ${totalShots} shots (avg ${avgShotsPerScene.toFixed(1)}/scene), ${totalKf} keyframes, ${compositionNotes} composition notes`);
    console.log(`[Google VDP Check] Shots per scene: [${shotsPerScene.join(', ')}], Target: ${d.minShotsPerScene}+ per scene`);
    
    if (scenes.length >= d.minScenes && totalShots >= d.minShots && totalKf >= d.minShots*d.minKfPerShot) {
      console.log(`[Adaptive Repair] âœ… Mode ${mode} density requirements met`);
      return repaired;
    }
    
    console.log(`[Adaptive Repair] âš ï¸ Mode ${mode} requirements partially met, proceeding`);
    return repaired;
  } catch (parseErr) {
    console.error(`[Adaptive Repair] âŒ Mode ${mode} repair failed:`, parseErr.message);
    return vdp;
  }
}

// Enhanced Density Computation Function
function computeDensity(vdp) {
  const scenes = Array.isArray(vdp?.scenes) ? vdp.scenes : [];
  const numScenes = scenes.length;
  let shots = 0, kf = 0;
  for (const s of scenes) {
    const shotsArr = Array.isArray(s?.shots) ? s.shots : [];
    shots += shotsArr.length;
    for (const sh of shotsArr) {
      kf += Array.isArray(sh?.keyframes) ? sh.keyframes.length : 0;
    }
  }
  return { numScenes, shots, kf };
}

// Density Floor Enforcement Function (Two-Pass VDP Generation)
async function ensureDensityFloor({ model, vdp, targets, meta }) {
  // Ensure targets are defined
  const safeTargets = targets || computeTargets(meta?.estimatedDurationSec || meta?.duration || 15, classifyMode(meta?.estimatedDurationSec || meta?.duration || 15));
  
  let { numScenes, shots, kf } = computeDensity(vdp);
  const needScene = numScenes < safeTargets.minScenes;
  const needShot  = shots     < (safeTargets.minShotsPerScene * Math.max(1, numScenes));
  const needKF    = kf        < (safeTargets.minKFPerShot    * Math.max(1, shots));
  
  if (!(needScene || needShot || needKF)) {
    console.log(`[Density Check] âœ… VDP meets density requirements: ${numScenes} scenes, ${shots} shots, ${kf} keyframes`);
    return vdp;
  }

  console.log(`[Density Floor] ğŸ”„ Expanding VDP - Current: ${numScenes}/${shots}/${kf}, Required: ${safeTargets.minScenes}/${safeTargets.minScenes * safeTargets.minShotsPerScene}/${safeTargets.minScenes * safeTargets.minShotsPerScene * safeTargets.minKFPerShot}`);

  // 2íŒ¨ìŠ¤ í™•ì¥ í”„ë¡¬í”„íŠ¸: í˜„ì¬ VDPë¥¼ ë„˜ê²¨ì£¼ê³  ë¶€ì¡±í•œ ìˆ˜ì¹˜(ì •í™•í•œ ìˆ«ì)ë¥¼ ìš”êµ¬
  const repairPrompt = `
ì•„ë˜ JSON VDPë¥¼ ê¸°ë°˜ìœ¼ë¡œ, ëˆ„ë½ëœ "shots[]"ì™€ ê° shotì˜ "keyframes[]"ë¥¼ ë°˜ë“œì‹œ ë³´ê°•í•˜ë¼.
ìµœì†Œ ìš”êµ¬ì¹˜:
- scenes >= ${safeTargets.minScenes}
- shots >= scenes * ${safeTargets.minShotsPerScene}
- keyframes >= shots * ${safeTargets.minKFPerShot}
ë˜í•œ ê° sceneì— composition.notes[], audio_events[]ë¥¼ í¬í•¨í•˜ë¼.
ê¸°ì¡´ hookGenome(start_sec, strength_score, microbeats_sec)ì€ ìœ ì§€/ì •êµí™”í•˜ë˜ ê°’ì€ ì¼ê´€ë˜ê²Œ.
ì ˆëŒ€ ì½”ë“œë¸”ëŸ­ ë§ˆí¬ë‹¤ìš´ ì—†ì´ ìˆœìˆ˜ JSON í•˜ë‚˜ë§Œ ì¶œë ¥í•˜ë¼.

PLATFORM CONTEXT:
- Platform: ${meta?.platform || 'unknown'}
- Language: ${meta?.language || 'ko'}

í˜„ì¬ VDP:
${JSON.stringify(vdp, null, 2)}
`;

  try {
    const model = createModel(); // Create fresh model instance
    const res = await model.generateContent([{ text: repairPrompt }]);
    let text = res.response?.candidates?.[0]?.content?.parts?.[0]?.text || "{}";
    text = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    
    const repaired = JSON.parse(text);

    // ë‹¤ì‹œ ë°€ë„ ì²´í¬
    const d2 = computeDensity(repaired);
    console.log(`[Density Repair] ğŸ“Š After expansion: ${d2.numScenes} scenes, ${d2.shots} shots, ${d2.kf} keyframes`);
    
    if (d2.numScenes >= safeTargets.minScenes &&
        d2.shots >= d2.numScenes * safeTargets.minShotsPerScene &&
        d2.kf >= Math.max(1, d2.shots) * safeTargets.minKFPerShot) {
      console.log(`[Density Floor] âœ… Successfully expanded VDP to meet requirements`);
      return repaired;
    }
    
    console.log(`[Density Floor] âš ï¸ Expansion still below requirements, but proceeding`);
    return repaired;
  } catch (parseErr) {
    console.error(`[Density Floor] âŒ Expansion failed:`, parseErr.message);
    console.log(`[Density Floor] ğŸ”„ Returning original VDP with density warning`);
    return vdp;
  }
}

// Verbosity Floor Validation Function
function validateVerbosityFloor(vdp) {
  const issues = [];
  const scenes = vdp.scenes || [];
  
  // Target metrics using configurable density thresholds
  const targetScenes = DENSITY_SCENES_MIN;
  const targetShots = DENSITY_SCENES_MIN * DENSITY_MIN_SHOTS_PER_SCENE;
  const targetKeyframes = targetShots * DENSITY_MIN_KF_PER_SHOT;
  
  // Count current metrics
  const sceneCount = scenes.length;
  const shotCount = scenes.reduce((acc, s) => acc + (s.shots?.length || 0), 0);
  const keyframeCount = scenes.reduce((acc, s) => 
    acc + (s.shots?.reduce((sa, sh) => sa + (sh.keyframes?.length || 0), 0) || 0), 0);
  
  // Check minimum thresholds
  if (sceneCount < targetScenes) {
    issues.push(`scenes: ${sceneCount} < ${targetScenes} minimum`);
  }
  
  if (shotCount < targetShots) {
    issues.push(`shots: ${shotCount} < ${targetShots} minimum`);
  }
  
  if (keyframeCount < targetKeyframes) {
    issues.push(`keyframes: ${keyframeCount} < ${targetKeyframes} minimum`);
  }
  
  // Check for missing mandatory arrays
  for (let i = 0; i < scenes.length; i++) {
    const scene = scenes[i];
    if (!scene.shots || scene.shots.length === 0) {
      issues.push(`scene[${i}] missing shots[] array`);
      continue;
    }
    
    if (!scene.narrative_unit?.summary || scene.narrative_unit.summary.length < 90) {
      issues.push(`scene[${i}] summary too short (< 90 chars)`);
    }
    
    for (let j = 0; j < scene.shots.length; j++) {
      const shot = scene.shots[j];
      if (!shot.keyframes || shot.keyframes.length < DENSITY_MIN_KF_PER_SHOT) {
        issues.push(`scene[${i}].shot[${j}] has < ${DENSITY_MIN_KF_PER_SHOT} keyframes`);
      }
      
      if (!shot.composition?.notes || shot.composition.notes.length === 0) {
        issues.push(`scene[${i}].shot[${j}] missing composition.notes`);
      }
    }
  }
  
  return {
    passed: issues.length === 0,
    issues,
    metrics: {
      scenes: sceneCount,
      shots: shotCount,
      keyframes: keyframeCount
    },
    targets: {
      scenes: targetScenes,
      shots: targetShots,  
      keyframes: targetKeyframes
    }
  };
}

app.post("/api/vdp/extract-vertex", async (req, res) => {
  try {
    const { gcsUri, meta = {}, outGcsUri } = req.body || {};
    if (!gcsUri) return res.status(400).json({ error: "gcsUri required" });

    // ì´ì¤‘ ì•ˆì „ì¥ì¹˜: ì„œë²„ ì¸¡ content_id/platform ì •ê·œí™”
    const normalizedMeta = await ensureContentId(meta);

    // ë¹„ë™ê¸° íŒ¨í„´ ê°ì§€ (outGcsUri ìˆìœ¼ë©´ 202 ëª¨ë“œ)
    const isAsyncMode = !!outGcsUri;
    const taskId = isAsyncMode ? `vdp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}` : null;

    console.log(`[VDP 2.0 Enhanced] Processing: ${gcsUri} with Google VDP quality standards`);
    console.log(`[VDP 2.0 Enhanced] Normalized meta:`, JSON.stringify(normalizedMeta, null, 2));

    // 2) Enhanced prompt with Google VDP quality standards
    const vdp20EnhancedPrompt = `${hookPrompt}

PLATFORM CONTEXT:
- Platform: ${normalizedMeta.platform || 'unknown'}
- Language: ${normalizedMeta.language || 'ko'}
- Content ID: ${normalizedMeta.content_id || 'unknown'}
- Canonical URL: ${normalizedMeta.canonical_url || normalizedMeta.source_url || 'N/A'}

CRITICAL: Respond with VALID JSON only. No markdown formatting, no code blocks.

GOOGLE VDP QUALITY ENFORCEMENT:
- MANDATORY: Every scene MUST include shots[] array (1-6 shots per scene)
- MANDATORY: Every shot MUST include keyframes[] array (2-4 keyframes per shot)
- MANDATORY: Every shot MUST include composition object with notes[] array
- PRIORITY: Hook scenes (narrative_role=Hook) require importance:"critical"
- VERBOSITY_FLOOR: Minimum detail requirements by scene duration
- MICRO_SCENE_DETAIL: Critical scenes require â‰¥3 keyframes + â‰¥2 composition notes
- Source URL: ${normalizedMeta.canonical_url || normalizedMeta.source_url || 'N/A'}

ENHANCED VDP 2.0 REQUIREMENTS:
- Include engagement_snapshot if available
- Provide story_telling analysis with plot structure 
- Extract microbeats_sec for precise hook timing
- Identify trigger_modalities (visual, audio, text)
- Add scene-level camera and audio metadata
- Support flexible pattern_code (string or array)

Return a complete VDP 2.0 JSON structure.`;

    // ë™ì  ëª©í‘œì¹˜ ê³„ì‚° ê¸°ë°˜ ì²˜ë¦¬
    const duration = meta?.duration_sec; // should be provided by ffprobe or yt-dlp metadata
    const mode = classifyMode(duration);
    const dynamicTargets = getDensityRequirements(mode, duration);
    
    console.log(`[Dynamic VDP] ğŸ¯ Mode ${mode} (${duration || 'unknown'}s) targets: ${dynamicTargets.minScenes} scenes, ${dynamicTargets.minShots} shots, ${dynamicTargets.minShots * dynamicTargets.minKfPerShot} keyframes, hookâ‰¤${(dynamicTargets.hookStartMaxFactor * (duration || 3)).toFixed(1)}s`);

    // 3) fileData íŒ¨í„´ìœ¼ë¡œ Vertex AI í˜¸ì¶œ (INVALID_ARGUMENT í•´ê²°)
    console.log(`[VDP fileData] ğŸ¯ Starting fileData pattern generation for: ${gcsUri}`);
    
    let vdp = null;
    let retryCount = 0;
    const maxRetries = 2;
    
    while (!vdp && retryCount <= maxRetries) {
      const isRetry = retryCount > 0;
      console.log(`[VDP fileData] ${isRetry ? `Retry ${retryCount}` : 'Initial attempt'} for: ${gcsUri}`);
      
      try {
        // Create fresh model for each request (ì•ˆì •ì„± í–¥ìƒ)
        const model = createModel();
        console.log(`[DEBUG] Fresh model created for request: ${typeof model}`);
        
        // fileData íŒ¨í„´ìœ¼ë¡œ ë¹„ë””ì˜¤ ì…ë ¥ (í…ìŠ¤íŠ¸ ê¸°ë°˜ ì…ë ¥ ëŒ€ì‹ )
        const request = {
          contents: [{
            role: "user",
            parts: [
              { fileData: { fileUri: gcsUri, mimeType: "video/mp4" } }, // camelCase
              { text: vdp20EnhancedPrompt }                              // ë¶„ì„ ì§€ì‹œ í”„ë¡¬í”„íŠ¸
            ]
          }]
        };
        
        console.log(`[DEBUG] fileData API request structure: fileUri=${gcsUri}, mimeType=video/mp4`);
        
        // Vertex AI í˜¸ì¶œ with fileData pattern
        const result = await model.generateContent(request);
        
        // Response í…ìŠ¤íŠ¸ ì¶”ì¶œ (JSON ê°•ì œ ì¶œë ¥ ì²˜ë¦¬)
        const raw = result?.response?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";
        
        console.log(`[VDP fileData] ğŸ“„ Response received: ${raw.length} chars`);
        
        // JSON íŒŒì‹± (Enhanced strict extraction)
        try {
          vdp = extractJsonStrict(raw);
        } catch (e) {
          // ë¡œê¹… í™•ì¥: ë¬¸ì œ êµ¬ê°„ ìš”ì•½
          console.error("[JSON-Parse] fail len=%d msg=%s", raw.length, e.message);
          throw e;
        }
        
        console.log(`[VDP fileData] âœ… Generation complete for: ${vdp.content_id || 'unknown'}`);
        break;
        
      } catch (vertexErr) {
        // Vertex AI ì—ëŸ¬ ë¶„ë¥˜ ë° ì¬ì‹œë„ ì‚¬ìœ  ë¡œê¹…
        const errorMsg = vertexErr?.message || 'Unknown error';
        const statusCode = vertexErr?.response?.status;
        let retryReason = 'unknown';
        let shouldRetry = retryCount < maxRetries;
        
        // ì—ëŸ¬ ìœ í˜•ë³„ ë¶„ë¥˜
        if (errorMsg.includes('INVALID_ARGUMENT')) {
          retryReason = 'invalid_argument_filedata';
        } else if (errorMsg.includes('timeout') || errorMsg.includes('TIMEOUT')) {
          retryReason = 'timeout';
        } else if (errorMsg.includes('socket') || errorMsg.includes('ECONNRESET')) {
          retryReason = 'network_connection';
        } else if (statusCode === 429) {
          retryReason = 'rate_limit';
          shouldRetry = false; // Rate limitì€ ì¬ì‹œë„í•˜ì§€ ì•ŠìŒ
        } else if (statusCode === 503 || statusCode === 502) {
          retryReason = 'service_unavailable';
        } else if (errorMsg.includes('quota') || errorMsg.includes('QUOTA')) {
          retryReason = 'quota_exceeded';
          shouldRetry = false; // Quota ì´ˆê³¼ëŠ” ì¬ì‹œë„í•˜ì§€ ì•ŠìŒ
        }
        
        console.error("[Vertex ERROR]", vertexErr?.message);
        console.log(`[Vertex Error Classification] error_type="${retryReason}", status_code=${statusCode}, retry_eligible=${shouldRetry}, retry_count=${retryCount}/${maxRetries}`);
        
        if (vertexErr?.response) {
          console.error("status:", vertexErr.response.status);
          console.error("data:", JSON.stringify(vertexErr.response.data || {}, null, 2));
        }
        
        if (shouldRetry && retryCount < maxRetries) {
          console.error(`[VDP fileData Error - Retry ${retryCount}] Reason: ${retryReason}, Message: ${vertexErr.message}`);
          retryCount++;
          await new Promise(resolve => setTimeout(resolve, 1000 * retryCount)); // ì§€ìˆ˜ ë°±ì˜¤í”„
          continue;
        }
        
        console.error("[VDP fileData Error - Final]", vertexErr.message);
        
        return res.status(422).json({ 
          type: "https://api.outlier.example/problems/vertex-filedata-failed",
          title: "Vertex AI fileData Generation Failed",
          status: 422,
          detail: "fileData pattern VDP generation failed after retries. Check region/model configuration.",
          instance: `/api/vdp/extract-vertex`,
          vertexError: vertexErr.message,
          retryCount,
          recommendedFixes: [
            "Verify us-central1 region configuration",
            "Check gemini-2.5-pro model availability",
            "Validate GCS URI format and accessibility",
            "Review responseMimeType: 'application/json' setting"
          ]
        });
      }
    }

    // 5) VDP 2.0 metadata enrichment (using normalized meta)
    if (normalizedMeta.platform) {
      vdp.metadata = vdp.metadata || {};
      vdp.metadata.platform = normalizedMeta.platform;
      vdp.metadata.content_id = normalizedMeta.content_id;
      vdp.metadata.language = normalizedMeta.language || 'ko';
      if (normalizedMeta.canonical_url) vdp.metadata.canonical_url = normalizedMeta.canonical_url;
      if (normalizedMeta.source_url) vdp.metadata.source_url = normalizedMeta.source_url;
      if (normalizedMeta.original_url) vdp.metadata.original_url = normalizedMeta.original_url;
    }

    // 6) Hook Genome Validation (NEW hybrid schema structure)
    const hg = vdp?.overall_analysis?.hookGenome;
    if (!hg) {
      return res.status(422).json({ 
        type: "https://api.outlier.example/problems/missing-hook-genome",
        title: "Hook Genome Missing",
        status: 422,
        detail: "2-Pass VDP requires hookGenome in overall_analysis structure",
        instance: `/api/vdp/extract-vertex`,
        vdp 
      });
    }

    // Hook Quality Gates with 2-Pass VDP validation  
    const vdpDuration = vdp?.media?.duration_sec; // Updated for hybrid schema
    const vdpMode = classifyMode(vdpDuration);
    const hookLimit = Math.min(HOOK_MAX_S, (vdpDuration || 0) * (vdpMode === 'S' ? 0.4 : 1.0));
    console.log(`[2-Pass Hook] Mode ${vdpMode} for ${vdpDuration}s video: hook limit ${hookLimit}s`);
    const startOK = typeof hg.start_sec === "number" && hg.start_sec <= (hookLimit || HOOK_MAX_S);
    const strengthOK = typeof hg.strength_score === "number" && hg.strength_score >= HOOK_MIN;
    const patternOK = hg.pattern_code && (typeof hg.pattern_code === "string" || Array.isArray(hg.pattern_code));
    
    const qualityIssues = [];
    if (!startOK) qualityIssues.push(`start_sec ${hg.start_sec} exceeds ${hookLimit || HOOK_MAX_S}s limit (mode ${vdpMode})`);
    if (!strengthOK) qualityIssues.push(`strength_score ${hg.strength_score} below ${HOOK_MIN} threshold`);
    if (!patternOK) qualityIssues.push("pattern_code must be string or non-empty array");
    
    if (qualityIssues.length > 0) {
      return res.status(409).json({ 
        type: "https://api.outlier.example/problems/hook-quality-gate-failed",
        title: "Hook Quality Gate Failed", 
        status: 409,
        detail: `VDP 2.0 quality gates failed: ${qualityIssues.join(', ')}`,
        instance: `/api/vdp/extract-vertex`,
        hookGenome: hg,
        qualityIssues
      });
    }

    // 6.5) Evidence Pack Merger - Merge audio fingerprints and product evidence
    let finalVdp = vdp;
    try {
      const evidencePacks = {};
      const meta = req.body?.meta || {};
      
      if (meta.audioFpGcsUri) {
        const { readJsonFromGcs } = await import('./utils/gcs-json.js');
        evidencePacks.audio = await readJsonFromGcs(meta.audioFpGcsUri);
      }
      
      if (meta.productEvidenceGcsUri) {
        const { readJsonFromGcs } = await import('./utils/gcs-json.js');
        evidencePacks.product = await readJsonFromGcs(meta.productEvidenceGcsUri);
      }
      
      if (evidencePacks.audio || evidencePacks.product) {
        const { applyEvidencePack } = await import('./utils/apply-evidence.js');
        finalVdp = applyEvidencePack(vdp, evidencePacks);
        console.log('[VDP Evidence] Evidence merged:', {
          audio: !!evidencePacks.audio,
          product: !!evidencePacks.product
        });
      }
    } catch (evidenceError) {
      console.error('[VDP Evidence] Evidence merge failed:', evidenceError?.message);
      // Continue with original VDP if evidence merge fails
    }

    // 6.9) ìµœì¢… VDP í•„ë“œ ê°•ì œ ë³´ê°• - BigQuery ì ì¬ ì‹¤íŒ¨ 0%
    const rawPlatform = req.body?.meta?.platform || req.body?.platform || 'YouTube';
    const normalizedPlatform = normalizePlatform(rawPlatform);
    const displayPlatform = getPlatformDisplayName(rawPlatform);
    const contentId = req.body?.contentId || req.body?.meta?.content_id || vdp?.video_id || 'unknown';

    // í•„ìˆ˜ í•„ë“œ ê°•ì œ ë³´ì¥
    finalVdp.content_id = finalVdp.content_id || contentId;
    finalVdp.metadata = finalVdp.metadata || {};
    finalVdp.metadata.platform = finalVdp.metadata.platform || displayPlatform;
    finalVdp.metadata.language = finalVdp.metadata.language || req.body?.meta?.language || 'ko';
    finalVdp.metadata.video_origin = finalVdp.metadata.video_origin || req.body?.meta?.video_origin || 'real_footage';
    finalVdp.metadata.canonical_url = finalVdp.metadata.canonical_url || req.body?.meta?.source_url || req.body?.sourceUrl || '';
    
    // ì „ì—­ ìœ ë‹ˆí¬ í‚¤ ìƒì„± (í‘œì¤€ í˜•ì‹)
    finalVdp.content_key = finalVdp.content_key || generateContentKey(normalizedPlatform, finalVdp.content_id);
    
    // RFC-3339 UTC íƒ€ì„ìŠ¤íƒ¬í”„ + ë‚ ì§œ í•„ë“œ
    finalVdp.load_timestamp = new Date().toISOString(); // RFC-3339 Z
    finalVdp.load_date = finalVdp.load_timestamp.substring(0, 10); // YYYY-MM-DD

    logger.contentIdHotfix(
      finalVdp.content_id,
      finalVdp.metadata.platform,
      !!finalVdp.metadata.canonical_url,
      correlationId
    );

    console.log('[VDP Final Fields] Enforced standards:', {
      content_key: finalVdp.content_key,
      content_id: finalVdp.content_id,
      platform: finalVdp.metadata.platform,
      load_date: finalVdp.load_date,
      load_timestamp: finalVdp.load_timestamp
    });

    // 7) í‘œì¤€ GCS ê²½ë¡œ ê°•ì œ + ì €ì¥ (Eventarc í˜¸í™˜)
    const RAW_BUCKET = process.env.RAW_BUCKET || 'tough-variety-raw';
    const standardOutPath = `gs://${RAW_BUCKET}/raw/vdp/${normalizedPlatform}/${finalVdp.content_id}.NEW.universal.json`;
    
    // outGcsUriê°€ ì—†ê±°ë‚˜ í‘œì¤€ê³¼ ë‹¤ë¥´ë©´ í‘œì¤€ ê²½ë¡œë¡œ ê°•ì œ
    const actualOutGcsUri = outGcsUri && isValidGcsPath(outGcsUri) ? outGcsUri : standardOutPath;
    
    console.log('[VDP Path] Standard path enforced:', {
      requested: outGcsUri || 'none',
      actual: actualOutGcsUri,
      normalized_platform: normalizedPlatform,
      display_platform: displayPlatform,
      content_id: finalVdp.content_id,
      content_key: finalVdp.content_key
    });

    if (actualOutGcsUri && finalVdp) {
      try {
        const savedPath = await saveJsonToGcs(actualOutGcsUri, finalVdp);
        console.log(`[VDP_UPLOAD] âœ… Saved VDP to: ${savedPath}`);
        finalVdp.processing_metadata = finalVdp.processing_metadata || {};
        finalVdp.processing_metadata.gcs_saved = true;
        finalVdp.processing_metadata.gcs_path = savedPath;
      } catch (gcsError) {
        console.error(`[VDP_UPLOAD_ERROR] âŒ Failed to save to GCS: ${gcsError.message}`);
        // ì‹¤íŒ¨í•´ë„ ë³¸ë¬¸ìœ¼ë¡œëŠ” í•­ìƒ VDP ë°˜í™˜ (í´ë¼ì´ì–¸íŠ¸ê°€ ìŠ¹ê²© ê°€ëŠ¥)
        finalVdp.processing_metadata = finalVdp.processing_metadata || {};
        finalVdp.processing_metadata.gcs_saved = false;
        finalVdp.processing_metadata.gcs_error = gcsError.message;
      }
    }

    // 8) Token Efficiency Analysis & Response Preparation
    const scenes = finalVdp.scenes || [];
    const totalShots = scenes.reduce((acc, s) => acc + (s.shots?.length || 0), 0);
    const totalKeyframes = scenes.reduce((acc, s) => acc + (s.shots?.reduce((sa, sh) => sa + (sh.kf?.length || 0), 0) || 0), 0);
    
    // Token efficiency metrics (estimated)
    const estimatedTokens = JSON.stringify(finalVdp).length * 0.75; // Rough token estimation
    const tokenEfficiency = estimatedTokens < 6000 ? "EXCELLENT" : estimatedTokens < 10000 ? "GOOD" : "NEEDS_OPTIMIZATION";
    
    // Enhanced VDP quality metrics logging
    const compositionNotes = scenes.reduce((acc, s) => acc + (s.shots?.reduce((sa, sh) => sa + (sh.composition?.notes?.length || 0), 0) || 0), 0);
    const averageNotesPerShot = totalShots > 0 ? (compositionNotes / totalShots).toFixed(1) : '0';
    const hookStartSec = hg?.start_sec || 0;
    const hookStrength = hg?.strength_score || 0;
    const finalVdpMode = classifyMode(finalVdp?.media?.duration_sec);
    
    console.log(`[2-Pass VDP] âœ… Final Success: ${finalVdp.content_id || 'unknown'} - Hook: ${JSON.stringify(hg.pattern_code)} (${hg.strength_score})`);
    console.log(`[Token Efficiency] Estimated tokens: ${Math.round(estimatedTokens)}, Efficiency: ${tokenEfficiency}`);
    console.log(`[Structure Quality] ${scenes.length} scenes, ${totalShots} shots, ${totalKeyframes} keyframes, ${finalVdp.context ? 'context included' : 'no context'}`);
    console.log(`[VDP Quality Metrics] mode=${finalVdpMode}, composition_notes=${compositionNotes}, avg_notes_per_shot=${averageNotesPerShot}, hook_timing=${hookStartSec}s, hook_strength=${hookStrength}`);
    console.log(`[Hook Genome Quality] pattern_code="${hg?.pattern_code}", start_sec=${hookStartSec}, strength_score=${hookStrength}, delivery="${hg?.delivery || 'unknown'}", microbeats_sec=${hg?.microbeats_sec || 'unknown'}"`);
    
    // Double Safety íš¨ê³¼ì„± ì¸¡ì •ì„ ìœ„í•œ ë©”íƒ€ë°ì´í„° í¬í•¨ ì—¬ë¶€ ì²´í¬
    const hasCanonicalUrl = !!finalVdp.metadata?.canonical_url;
    const hasOriginalUrl = !!finalVdp.metadata?.original_url;
    const platformNormalized = normalizedMeta.platform !== meta.platform;
    const contentIdNormalized = normalizedMeta.content_id !== meta.content_id;
    console.log(`[Double Safety Results] canonical_url_added=${hasCanonicalUrl}, original_url_added=${hasOriginalUrl}, platform_corrected=${platformNormalized}, content_id_corrected=${contentIdNormalized}`);
    
    // Add processing metadata for monitoring
    finalVdp.processing_metadata = {
      schema_version: "hybrid-optimized-v1.0",
      token_efficiency: {
        estimated_tokens: Math.round(estimatedTokens),
        efficiency_rating: tokenEfficiency,
        target_range: "4000-6000",
        optimization_method: "2-pass-streaming"
      },
      structure_quality: {
        scenes_count: scenes.length,
        shots_count: totalShots,
        keyframes_count: totalKeyframes,
        has_context: !!vdp.context,
        redundancy_eliminated: true
      },
      hook_quality_gates: {
        hook_timing: startOK,
        hook_strength: strengthOK, 
        pattern_code: patternOK,
        gate_status: startOK && strengthOK && patternOK ? "PASSED" : "FAILED"
      },
      generation_metadata: {
        platform: meta.platform || 'unknown',
        timestamp: new Date().toISOString(),
        model: process.env.MODEL_NAME || "gemini-2.5-pro",
        method: "2-pass-streaming",
        retry_count: retryCount,
        pass_1: "structure_generation",
        pass_2: "detail_streaming",
        old_vdp_principles_applied: true
      }
    };
    
    // ë¹„ë™ê¸° 202 + GCS í´ë§ íŒ¨í„´
    if (isAsyncMode && outGcsUri) {
      console.log(`[VDP 2.0 Async] Task: ${taskId}, Output: ${outGcsUri}`);
      
      // ë°±ê·¸ë¼ìš´ë“œì—ì„œ GCSì— VDP ì €ì¥ (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” í/ì›Œì»¤ ì‚¬ìš©)
      setTimeout(async () => {
        try {
          const { Storage } = await import('@google-cloud/storage');
          const storage = new Storage({ projectId: PROJECT_ID });
          const bucket = storage.bucket(outGcsUri.split('/')[2]);
          const fileName = outGcsUri.split('/').slice(3).join('/');
          const file = bucket.file(fileName);
          
          await file.save(JSON.stringify(finalVdp, null, 2), {
            metadata: { contentType: 'application/json' }
          });
          console.log(`[Async Complete] VDP saved to ${outGcsUri}`);
        } catch (err) {
          console.error(`[Async Error] Failed to save to ${outGcsUri}:`, err.message);
        }
      }, 1000); // 1ì´ˆ ì§€ì—° í›„ ì €ì¥
      
      return res.status(202).json({
        taskId: taskId,
        status: "processing",
        outGcsUri: outGcsUri,
        estimated_completion: new Date(Date.now() + 30000).toISOString(),
        polling_url: `/api/vdp/status/${taskId}`,
        message: "VDP generation complete - check outGcsUri in GCS"
      });
    }
    
    // Standard sync response - return VDP directly (no wrapper)
    return res.json(finalVdp);
  } catch (err) {
    console.error(`[VDP 2.0 Error] ${err.message}`, err);
    return res.status(500).json({ 
      error: err.message,
      timestamp: new Date().toISOString(),
      model: process.env.MODEL_NAME || "gemini-2.5-pro"
    });
  }
});

app.get("/health", (_, res) => res.json({ ok: true }));

// Test endpoint for VDP 2.0 quality gates (bypasses Vertex AI)
app.post("/api/vdp/test-quality-gates", (req, res) => {
  try {
    const { vdp } = req.body || {};
    if (!vdp) return res.status(400).json({ error: "vdp data required" });

    console.log(`[VDP 2.0 TEST] Testing quality gates for: ${vdp.content_id || 'unknown'}`);

    // VDP 2.0 Hook Quality Gates (enhanced validation)
    const hg = vdp?.overall_analysis?.hookGenome;
    if (!hg) {
      return res.status(422).json({ 
        type: "https://api.outlier.example/problems/missing-hook-genome",
        title: "Hook Genome Missing",
        status: 422,
        detail: "VDP 2.0 requires hookGenome in overall_analysis structure",
        instance: `/api/vdp/test-quality-gates`,
        vdp 
      });
    }

    // VDP 2.0 enhanced quality gates with dynamic hook limits
    const testDuration = vdp?.metadata?.duration_sec; // ffprobe ë˜ëŠ” yt-dlp ë©”íƒ€ì—ì„œ ì „ë‹¬
    const testMode = classifyMode(testDuration);
    const hookLimit = Math.min(HOOK_MAX_S, (testDuration || 0) * DENSITY[testMode].hookStartMaxFactor);
    console.log(`[Adaptive Hook Test] Mode ${testMode} for ${testDuration}s video: hook limit ${hookLimit}s (factor: ${DENSITY[testMode].hookStartMaxFactor})`);
    const startOK = typeof hg.start_sec === "number" && hg.start_sec <= (hookLimit || HOOK_MAX_S);
    const strengthOK = typeof hg.strength_score === "number" && hg.strength_score >= HOOK_MIN;
    const patternOK = hg.pattern_code && (typeof hg.pattern_code === "string" || Array.isArray(hg.pattern_code));
    
    const testQualityIssues = [];
    if (!startOK) testQualityIssues.push(`start_sec ${hg.start_sec} exceeds ${hookLimit || HOOK_MAX_S}s limit (mode ${testMode})`);
    if (!strengthOK) testQualityIssues.push(`strength_score ${hg.strength_score} below ${HOOK_MIN} threshold`);
    if (!patternOK) testQualityIssues.push("pattern_code must be string or non-empty array");
    
    if (testQualityIssues.length > 0) {
      return res.status(409).json({ 
        type: "https://api.outlier.example/problems/hook-quality-gate-failed",
        title: "Hook Quality Gate Failed", 
        status: 409,
        detail: `VDP 2.0 quality gates failed: ${testQualityIssues.join(', ')}`,
        instance: `/api/vdp/test-quality-gates`,
        hookGenome: hg,
        qualityIssues: testQualityIssues
      });
    }

    // Success Response
    console.log(`[VDP 2.0 TEST] Success: ${vdp.content_id} - Hook: ${hg.pattern_code} (${hg.strength_score})`);
    
    return res.json({ 
      ok: true, 
      vdp,
      schema_version: "2.0",
      quality_gates: {
        hook_timing: startOK,
        hook_strength: strengthOK, 
        pattern_code: patternOK
      },
      processing_metadata: {
        platform: vdp.metadata?.platform || 'unknown',
        timestamp: new Date().toISOString(),
        test_mode: true
      }
    });
  } catch (err) {
    return res.status(500).json({ error: (err instanceof Error ? err.message : String(err)) });
  }
});

const PORT = process.env.PORT || 8080;
const server = app.listen(PORT, () => console.log(`[t2-extract] listening on ${PORT}`));

// VDP ìƒì„±ì„ ìœ„í•œ ìµœì í™”ëœ íƒ€ì„ì•„ì›ƒ ì„¤ì •
server.keepAliveTimeout = 120000;   // 120ì´ˆ Keep-Alive
server.headersTimeout = 125000;     // 125ì´ˆ í—¤ë” íƒ€ì„ì•„ì›ƒ 
server.requestTimeout = 0;          // ìš”ì²­ì€ ë¬´ì œí•œ (VDP ìƒì„± ì‹œê°„)

console.log(`[t2-extract] íƒ€ì„ì•„ì›ƒ ì„¤ì •: requestTimeout=${server.requestTimeout}, headersTimeout=${server.headersTimeout}, keepAliveTimeout=${server.keepAliveTimeout}`);
